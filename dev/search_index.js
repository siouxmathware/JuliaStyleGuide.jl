var documenterSearchIndex = {"docs":
[{"location":"nested_includes/#Nested-includes","page":"Nested Include","title":"Nested includes","text":"","category":"section"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"If your package consists of many files being included, it is possibly a good idea to create some ordering in the included files.  Please note, however, that this is also a good moment to reconsider the scope of the package! If you are convinced that the package scope is OK, but a folder structure makes sense, please follow these guidelines.","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"The general idea is that:","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"At the top-level src/MyPackage.jl maintains the same structure as before.\nAll sub-includes are in one file within the subdirectory that is obviously the top-level.","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"The resulting file structure should look something like","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"|-- src/\n|    |-- bigstuff/\n|    |    |-- bigstuff.jl\n|    |    |-- fileio.jl\n|    |    |-- methods.jl\n|    |    |-- types.jl\n|    |-- MyPackage.jl\n|    |-- smallstuff.jl\n|    |-- tinystuff.jl","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"The inclusion of the code in the folder bigstuff is done entirely by bigstuff/bigstuff.jl and that is all it does.","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"# MyPackage/src/bigstuff/bigstuff.jl\ninclude(\"bigstuff/types.jl\")\ninclude(\"bigstuff/methods.jl\")\ninclude(\"bigstuff/read.jl\")\n# note that the export statements remain at the top-level in MyPackage.jl","category":"page"},{"location":"nested_includes/#Rule-of-thumb","page":"Nested Include","title":"Rule of thumb","text":"","category":"section"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"Any file should either","category":"page"},{"location":"nested_includes/","page":"Nested Include","title":"Nested Include","text":"Contain no include calls\nBe a module consisting only of using, import, export statements and include calls\nA module small enough to not need any include calls at all.","category":"page"},{"location":"naming_and_casing/#Naming-and-casing","page":"Naming and casing","title":"Naming and casing","text":"","category":"section"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"\"There are only two hard things in Computer Science: cache invalidation and naming things.\" - Phil Karlton","category":"page"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"We will not even attempt to provide a general solution to the problem of naming objects, but do clarify some details.","category":"page"},{"location":"naming_and_casing/#Casing","page":"Naming and casing","title":"Casing","text":"","category":"section"},{"location":"naming_and_casing/#Functions-and-methods","page":"Naming and casing","title":"Functions and methods","text":"","category":"section"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"Follow the Blue convention: adopt a snake_case for function names.  But: please appreciate that motivation for Julia's advice to simply concatenate the words in function names is because function names should be short! In particular, the name of the function should not include information that is already evident from the argument types.","category":"page"},{"location":"naming_and_casing/#Packages,-Types-and-Structs","page":"Naming and casing","title":"Packages, Types and Structs","text":"","category":"section"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"Here we follow both the Julia and Blue style to use CamelCase, but with the following clarification. The casing is to be adhered to strictly.  This means that if one of the constituents of the name is typically written in upper case, it must also be written with only an initial capital.  E.g.","category":"page"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"XmlWriter.jl\nSqmPlanner.jl\nPlayerId","category":"page"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"This might not play well with acronyms, but they are best avoided anyway.","category":"page"},{"location":"naming_and_casing/#Struct-fields-and-variable-names","page":"Naming and casing","title":"Struct fields and variable names","text":"","category":"section"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"Adopt a snake_case for struct fields and variable names. Beware not to add reduntant scoping to field names, e.g. a struct Car may have a color, but not a car_color. ","category":"page"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"\"The length of variable names should be proportional to their scope\" - Robert C. Martin","category":"page"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"This implies single (Greek) letter variables are only acceptable for the smallest of scopes, e.g. in lambda functions or one-liners. The effort you save yourself on typing is not worth the effort it costs others in reading.","category":"page"},{"location":"naming_and_casing/#Files-and-folders","page":"Naming and casing","title":"Files and folders","text":"","category":"section"},{"location":"naming_and_casing/","page":"Naming and casing","title":"Naming and casing","text":"To avoid all the nasty side-effects of working on different platforms, stick to lowercase file and folder names as much as possible.","category":"page"},{"location":"types_and_their_methods/#Types-and-Their-Methods","page":"Types and Their Methods","title":"Types and Their Methods","text":"","category":"section"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"Despite Julia not requiring to group data and methods together, it is generally helpful to organized your data and methods similarly to how traditional object-oriented programming works.","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"# src/Slotting.jl\n\ninclude(joinpath(\"types\", \"types.jl\"))\nexport AbstractContainer, Crate, Barrel  # exports remain at the top level","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"# src/types/types.jl\ninclude(joinpath(\"containers\", \"containers.jl\"))","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"# src/types/containers/containers.jl\ninclude(\"AbstractContainer.jl\")\ninclude(\"Crate.jl\")\ninclude(\"Barrel.jl\")","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"# src/types/containers/AbstractContainer.jl\nabstract type AbstractContainer end\n\n# interface, _must_ be implemented\nheight(::C) where {C<:AbstractContainer} = error(\"Method height not implemented for $C\")\nwidth(::C) where {C<:AbstractContainer} = error(\"Method width not implemented for $C\")\ndepth(::C) where {C<:AbstractContainer} = error(\"Method depth not implemented for $C\")\n\n# shared functionality, _may_ be overwritten\nvolume(c::AbstractContainer) = height(c) * width(c) * depth(c)","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"And concrete subtypes","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"# src/types/containers/Crate.jl\nstruct Crate <: AbstractContainer\n    height::Float64\n    width::Float64\n    depth::Float64\nend\n\nheight(c::Crate) = c.height\nwidth(c::Crate) = c.width\ndepth(c::Crate) = c.depth\n\nvolume(c::Crate) = height(c) * width(c) * depth(c)","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"and","category":"page"},{"location":"types_and_their_methods/","page":"Types and Their Methods","title":"Types and Their Methods","text":"# src/types/containers/Barrel.jl\nstruct Barrel <: AbstractContainer\n    height::Float64\n    radius::Float64\nend\n\nheight(b::Barrel) = b.height\nwidth(b::Barrel) = 2 * b.radius\ndepth(b::Barrel) = 2 * b.radius\n\nvolume(b::Barrel) = b.height * pi * b.radius^2","category":"page"},{"location":"package_interface_and_dependencies/#Package-interface-and-dependencies","page":"Package interface and dependencies","title":"Package interface and dependencies","text":"","category":"section"},{"location":"package_interface_and_dependencies/","page":"Package interface and dependencies","title":"Package interface and dependencies","text":"Anyone approaching a package should have an easy time understanding interface(s) and dependencies of the package.  In Julia, the interface(s) that a package promises to provide are determined by export statements.  Note that other (abstract) types, (concrete) structures and methods are also available to users, but a package does not promise stability for these.  The dependencies of a package are defined by its using and import statements. ","category":"page"},{"location":"package_interface_and_dependencies/","page":"Package interface and dependencies","title":"Package interface and dependencies","text":"All using, import and export statements belong in the main module file, src/MyModule.jl. Preferrably explicitly mention types, structures and methods that are being brought into scope by using or import.  Make a separation between external and internal packages.  To further help readers, place export statements adjacent to the include calls that define that which is exported.  Order the exported items in a sensible and consistent manner, e.g. alphabetically with types (capitalized) first.","category":"page"},{"location":"package_interface_and_dependencies/","page":"Package interface and dependencies","title":"Package interface and dependencies","text":"As an example, consider the following","category":"page"},{"location":"package_interface_and_dependencies/","page":"Package interface and dependencies","title":"Package interface and dependencies","text":"# Slotting/src/Slotting.jl\nmodule Slotting  \nusing DataFrames: DataFrame, combine, groupby\nusing Statistics: mean, std\nusing GLMakie\n\nusing InternalPackage: something\n\ninclude(\"errors.jl\")\n\ninclude(\"slotting.jl\")\nexport Result, slot\n\ninclude(\"slotting_plots.jl\")\nexport plot_items, plot_result\n\nend # module","category":"page"},{"location":"testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"testing/#ReTest","page":"Testing","title":"ReTest","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"Use  the ReTest package to allow developers to easily re-execute specific tests.  The ReTest package works best by defining a dedicated Test module, which is included in the runtests.jl.","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"The code should look something like the following:","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"# Slotting/test/runtests.jl\nusing ReTest\nusing Slotting\n\ninclude(\"SlottingTests.jl\")\n\n# when including this file (e.g. with `Pkg.test`), all the tests\n# in both modules will be run:\n\nretest(Slotting, SlottingTests)","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"# Slotting/test/SlottingTests.jl\nmodule SlottingTests\n\nusing ReTest\nusing StatsBase\n\nusing Slotting\n\ninclude(\"common.jl\")\n\ninclude(\"test_model.jl\")\ninclude(\"test_reconstruct.jl\")\nend","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"Note that you can conviently execute the runtests.jl file line-by-line in your REPL (e.g. using Shift+Enter in VSCode). This does require having any packages defined in test/Project.toml in your base environment. In many cases, this is restricted to ReTest itself and maybe some packages in Base","category":"page"},{"location":"testing/#Tests-structure","page":"Testing","title":"Tests structure","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"The structure of tests should mirror the structure of the code base. In the example above, the files test/test_model.jl and test/test_reconstruct.jl mirror files src/model.jl and src/reconstruct.jl.  It cannot be stressed enough that all these tests should be independent! ","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"Define the actual tests using the @testset macro.  Try to follow the \"3xA\" pattern: Arrange, Act, Assert (a.k.a. Given, When, Then) and the \"FIRST\" principles: Fast, Isolated, Repeatable, Self-validating, Thorough and Timely. The content of a test file may look like this, where we also demonstrate the convient use of for loops in testset defintion:","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"# Slotting/test/test_reconstruct.jl\n@testset \"Measurements\" begin\n    @testset \"Volume for radius = $radius ($(radius |> typeof))\" for radius in [0, 1, 1.0, pi, 1/sqrt(pi)]  # some interesting samples\n        # GIVEN a barrel of some dimensions\n        height = 1  # we could add a nested loop to test different heights too\n        barrel = Barrel(height, radius)  # create the object\n\n        # WHEN computing the volume\n        vol = volume(barrel)\n        \n        # THEN the volume is correct, at least approximately\n        @test isapprox(vol, height * pi * radius^2)\n    end\n\n    @testset \"Width for radius = $radius ($(radius |> typeof))\" for radius in [0, 1, 1.0, pi, 1/sqrt(pi)]  # some interesting samples\n        # GIVEN a barrel of some dimensions\n        height = 1  # we could add a nested loop to test different heights too\n        barrel = Barrel(height, radius)  # create the object\n\n        # WHEN computing the volume\n        w = Slotting.width(barrel)  # to access a non-exported item, we must specify the Package name\n        \n        # THEN the width is correct, at least approximately\n        @test isapprox(w == 2*radius)\n    end\nend","category":"page"},{"location":"#A-Style-Guide-for-writing-good-Julia","page":"Home","title":"A Style Guide for writing good Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are many style guides out there. To name a few: YASGuide, JuliaLang style guide and the Blue Style Guide. What is covered by these style guides is, however, limited largely to simple questions on details. We choose to stick the Blue Style Guide in principle.  Compliance to this style guide is easily achieved by using a Julia Formatter along with a JuliaFormatter.toml file, as used in this repo. This document intends to provide guidelines to elements not covered by the Blue style guide.","category":"page"},{"location":"#First-principles","page":"Home","title":"First principles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The guidelines in this document follow from first principles. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Software is \"soft\", it should be easy to change code to suit new requirements.\nGuidelines provide answers to simple questions to allow focus during code review to be on the important answers. (They prevent bikeshedding.)\nGuidelines are complementary to an autoformatter.","category":"page"},{"location":"#Guidelines","page":"Home","title":"Guidelines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The guidelines are discussed in separate chapters to be accessed via the menu on the left.","category":"page"},{"location":"documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Use Documenter.jl for creating documentation.      Its own documentation is a great starting point.      Be sure to also use the the correct DocTheme, see the code structure of this very repo (JuliaStyleGuide) as an example. ","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [JuliaStyleGuide]","category":"page"},{"location":"docstrings/#JuliaStyleGuide.examplemethod-Tuple{}","page":"Docstrings","title":"JuliaStyleGuide.examplemethod","text":"An example docstring for the method examplemethod\n\n\n\n\n\n","category":"method"}]
}
